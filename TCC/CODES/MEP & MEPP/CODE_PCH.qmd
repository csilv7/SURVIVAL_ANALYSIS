---
title: "Modelo Exponencial por Partes e Extensões"
subtitle: "usando os Modelos de Tempo de Vida Acelerado"

format:
  html:
    number-sections: true
    toc: true
    toc-location: left
  pdf:
    number-sections: true
    pdf-engine: xelatex
    geometry: "margin=2cm"
    fig-pos: "H"
    echo: false
    message: false
    warning: false
    
lang: "pt-BR"
---

# Modelagem de Dados Reais

```{r}
#| label: "Configurações do Ambiente"

# --------------------------
# [1] CONFIGURAÇÕES INICIAIS
# --------------------------

options(OutDec = ",")

# -------------------------
# [1.1] PACOTES NECESSÁRIOS
# -------------------------
library(dplyr)
library(eha)
library(ggplot2)

# ---------------------------
# [1.2] FUNÇÕES IMPLEMENTADAS
# ---------------------------
source("/cloud/project/CODES/TÉCNICAS PARAMÉTRICAS/PCH/MODELING_FUNCTIONS.R")
```

## Dados de Câncer de Mama

Utilizou-se um conjunto de dados reais sobre recidiva tumoral em pacientes com câncer de mama submetidas a diferentes tratamentos (Colosimo & Giolo, 2006), com variável resposta observada de forma intervalar.

```{r}
#| label: "Leitura e Ajuste dos Dados"

# ------------------------------
# [2] LEITURA E AJUSTE DOS DADOS
# ------------------------------

# Caminho URL do arquivo
url <- "https://docs.ufpr.br/~giolo/asa/dados/breast.txt"

# Leitura do arquivo
breast <- read.table(url, h = TRUE)

# Ajute nos dados
breast$left <- ifelse(breast$left == 0, 0.01, breast$left)     # Lim Inf
breast$right <- ifelse(is.na(breast$right), Inf, breast$right) # Lim Sup

# Variáveis fixas
y <- cbind(breast$left, breast$right) / 12 # Escala de: MESES -> ANOS
X <- as.matrix(breast$ther, ncol = 1)
cens <- breast$cens

# Partições a serem testadas
bmax.values <- 2:6

# Data frames para armazenar resultados
results <- data.frame(
  bmax = integer(),
  model = character(),
  AIC = numeric(),
  BIC = numeric(),
  stringsAsFactors = FALSE
)
```

### Ajuste via Modelo Exponencial por Partes

Será considerado que $T \sim \text{EP}(\boldsymbol{\tau^{\intercal}}, \boldsymbol{\lambda^{\intercal}})$, onde

* $\boldsymbol{\tau^{\intercal}} = (0, \tau_{1}, \tau_{2}, \ldots,\tau_{k}, \infty)^{\intercal}$ são as partições feitas no eixo do tempo;
* $\boldsymbol{\lambda^{\intercal}} = (\lambda_{1}, \lambda_{2}, \ldots, \lambda_{k+1})^{\intercal}$, são as taxas de falha dentro de cada partição gerada pelo vetor $\boldsymbol{\tau^{\intercal}}$.

Entretanto, é estimado apenas o vetor de taxas $\boldsymbol{\lambda^{\intercal}}$. Além desse vetor, é estimado o vetor de coeficientes ou, nesse caso, o coeficiente atraledo a única variável preditora  do conjunto de dados.

```{r}
#| label: "Ajuste MEP"

# -----------------------------
# [3] LOOP PARA AJUSTAR MODELOS
# -----------------------------
for (bmax in bmax.values) {
  # Criação e Ajustes das Partições
  cuts.grid <- time.grid.interval(li = y[, 1], ri = y[, 2], type = "OBS", bmax = bmax)
  cuts <- cuts.grid[c(-1, -length(cuts.grid))]
  
  # Ajustar Modelo Exponencial por Partes (MEP)
  n.par.MEP <- length(cuts.grid) + ncol(X) - 1
  init.MEP <- rep(1, n.par.MEP)
  fit.MEP <- optim(
    par = init.MEP, fn = loglikelihood.MEP, method = "BFGS", hessian = TRUE,
    interval = y, cens = cens, X = X, cuts.points = cuts, control = list(fnscale=-1)
  )
  
  # Calcular AIC e BIC do MEP
  AIC.MEP <- 2 * n.par.MEP - 2 * fit.MEP$value
  BIC.MEP <- n.par.MEP * log(nrow(y)) - 2 * fit.MEP$value
  
  # Armazanar resultados no Data Frame
  results <- rbind(
    results,
    data.frame(bmax = bmax, model = "MEP", AIC = AIC.MEP, BIC = BIC.MEP)
  )
}
```

### Ajuste via Modelo Exponencial por Partes Potência

Será considerado que $T \sim \text{EPP}(\boldsymbol{\tau^{\intercal}}, \boldsymbol{\lambda^{\intercal}}, \alpha)$, onde

* $\boldsymbol{\tau^{\intercal}} = (0, \tau_{1}, \tau_{2}, \ldots,\tau_{k}, \infty)^{\intercal}$ são as partições feitas no eixo do tempo;
* $\boldsymbol{\lambda^{\intercal}} = (\lambda_{1}, \lambda_{2}, \ldots, \lambda_{k+1})^{\intercal}$, são as taxas de falha dentro de cada partição gerada pelo vetor $\boldsymbol{\tau^{\intercal}}$ e;
* $\alpha$ como um parâmetro de potência que busca flexibilizar ainda mais o modelo.

Entretanto, é estimado apenas o vetor de taxas $\boldsymbol{\lambda^{\intercal}}$ e o parâmetro $\alpha$. Além desse vetor, é estimado o vetor de coeficientes ou, nesse caso, o coeficiente atraledo a única variável preditora  do conjunto de dados.

```{r}
#| label: "Ajuste MEPP"

# -----------------------------
# [3] LOOP PARA AJUSTAR MODELOS
# -----------------------------
for (bmax in bmax.values) {
  # Criação e Ajustes das Partições
  cuts.grid <- time.grid.interval(li = y[, 1], ri = y[, 2], type = "OBS", bmax = bmax)
  cuts <- cuts.grid[c(-1, -length(cuts.grid))]
  
  # Ajustar Modelo Exponencial por Partes Potência (MEPP)
  n.par.MEPP <- length(cuts.grid) + ncol(X)
  init.MEPP <- rep(1, n.par.MEPP)
  fit.MEPP <- optim(
    par = init.MEPP, fn = loglikelihood.MEPP, method = "BFGS", hessian = TRUE,
    interval = y, cens = cens, X = X, cuts.points = cuts, control = list(fnscale=-1)
  )
  
  # Calcular AIC e BIC do MEPP
  AIC.MEPP <- 2 * n.par.MEPP - 2 * fit.MEPP$value
  BIC.MEPP <- n.par.MEPP * log(nrow(y)) - 2 * fit.MEPP$value
  
  # Armazanar resultados no Data Frame
  results <- rbind(
    results,
    data.frame(bmax = bmax, model = "MEPP", AIC = AIC.MEPP, BIC = BIC.MEPP)
  )
}
```

### Comparação

```{r}
#| tbl-cap: "Comparação dos Resultados dos Modelos Exponencial por Partes e Extensões."
#| label: "tbl-Results"

knitr::kable(
  results, digits = 2,
  col.names = c("Nº Partições", "Modelo", "AIC", "BIC"),
  escape = FALSE,
  align = "c",
  booktabs = TRUE
)
```

```{r}
#| fig-cap: "Comparação dos Resultados dos Modelos Exponencial por Partes e Extensões."
#| fig-subcap: 
#| - "Críterio de Informação Akaike (AIC)"
#| - "Críterio de Informação Bayesiano (BIC)"
#| fig-dpi: 600
#| layout-ncol: 2
#| label: "fig-Results"

# -------------------------------
# [4] VISUALIZAÇÃO DOS RESULTADOS
# -------------------------------

# AIC versus Nº Partições
ggplot(results, aes(x = bmax, y = AIC, color = model)) +
  geom_line(lwd = 1.1) + geom_point(size = 3) +
  labs(x = "Número de Partições", y = "AIC", color = "") +
  theme_classic() +
  theme(
    legend.position = "top",
    axis.title.x = element_text(face = "bold"),
    axis.title.y = element_text(face = "bold")
  )

# BIC versus Nº Partições
ggplot(results, aes(x = bmax, y = BIC, color = model)) +
  geom_line(lwd = 1.1) + geom_point(size = 3) +
  labs(x = "Número de Partições", y = "BIC", color = "") +
  theme_classic() +
  theme(
    legend.position = "top",
    axis.title.x = element_text(face = "bold"),
    axis.title.y = element_text(face = "bold")
  )
```

# Modelagem via Monte Carlo



## Amostra de Tamanho 30

### Ajuste via Modelo Exponencial por Partes

### Ajuste via Modelo Exponencial por Partes Potência

## Amostra de Tamanho 50

### Ajuste via Modelo Exponencial por Partes

### Ajuste via Modelo Exponencial por Partes Potência

## Amostra de Tamanho 100

### Ajuste via Modelo Exponencial por Partes

### Ajuste via Modelo Exponencial por Partes Potência

## Amostra de Tamanho 500

### Ajuste via Modelo Exponencial por Partes

### Ajuste via Modelo Exponencial por Partes Potência

## Amostra de Tamanho 1000

### Ajuste via Modelo Exponencial por Partes

### Ajuste via Modelo Exponencial por Partes Potência